import Foundation

// MARK: - Helpers

/// Converts an SF Symbol raw name like "arrow.up.circle.fill" into a Swift camelCase
/// identifier like "arrowUpCircleFill". Leading-digit names get an underscore prefix.
func toCamelCase(_ name: String) -> String {
    // Split on dot, hyphen, and underscore
    let parts = name.components(separatedBy: CharacterSet(charactersIn: ".-_"))
    guard !parts.isEmpty else { return name }

    var result = ""
    for (index, part) in parts.enumerated() {
        guard !part.isEmpty else { continue }
        if index == 0 {
            result += part.lowercased()
        } else {
            result += part.prefix(1).uppercased() + part.dropFirst().lowercased()
        }
    }

    // Prefix with underscore if the identifier starts with a digit
    if let first = result.first, first.isNumber {
        result = "_" + result
    }

    // Escape Swift keywords
    let keywords: Set<String> = [
        "return", "continue", "break", "default", "case", "switch", "if", "else",
        "for", "while", "repeat", "do", "try", "catch", "throw", "throws",
        "rethrows", "import", "class", "struct", "enum", "protocol", "extension",
        "func", "var", "let", "in", "is", "as", "nil", "true", "false",
        "self", "Self", "super", "init", "deinit", "subscript", "operator",
        "typealias", "associatedtype", "where", "guard", "defer",
        "public", "private", "internal", "fileprivate", "open", "static",
        "final", "override", "required", "convenience", "lazy", "dynamic",
        "optional", "weak", "unowned", "mutating", "nonmutating", "inout",
        "any", "some", "async", "await", "actor",
    ]
    if keywords.contains(result) {
        result = "`\(result)`"
    }

    return result
}

/// Converts a category key like "objectsandtools" into a Swift camelCase identifier.
/// Category keys are lowercase run-together words, so we need a word list heuristic.
/// Since the set is small (31 known keys), we use an explicit map.
let categoryKeyToCamelCase: [String: String] = [
    "all": "all",
    "whatsnew": "whatsNew",
    "multicolor": "multicolor",
    "variablecolor": "variableColor",
    "communication": "communication",
    "weather": "weather",
    "maps": "maps",
    "objectsandtools": "objectsAndTools",
    "devices": "devices",
    "cameraandphotos": "cameraAndPhotos",
    "gaming": "gaming",
    "connectivity": "connectivity",
    "transportation": "transportation",
    "automotive": "automotive",
    "accessibility": "accessibility",
    "privacyandsecurity": "privacyAndSecurity",
    "human": "human",
    "home": "home",
    "fitness": "fitness",
    "nature": "nature",
    "editing": "editing",
    "textformatting": "textFormatting",
    "media": "media",
    "keyboard": "keyboard",
    "commerce": "commerce",
    "time": "time",
    "health": "health",
    "shapes": "shapes",
    "arrows": "arrows",
    "indices": "indices",
    "math": "math",
]

// MARK: - Plist loading

struct CategoryInfo {
    let key: String
    let label: String
    let icon: String
    var caseName: String { categoryKeyToCamelCase[key] ?? key }
}

func loadCategories(from url: URL) throws -> [CategoryInfo] {
    let data = try Data(contentsOf: url)
    guard let array = try PropertyListSerialization.propertyList(from: data, format: nil) as? [[String: String]] else {
        throw GeneratorError.invalidPlist("categories.plist is not [[String: String]]")
    }
    return array.compactMap { dict in
        guard let key = dict["key"], let label = dict["label"], let icon = dict["icon"] else { return nil }
        return CategoryInfo(key: key, label: label, icon: icon)
    }
}

/// Returns [symbolName: [categoryKey]]
func loadSymbolCategories(from url: URL) throws -> [String: [String]] {
    let data = try Data(contentsOf: url)
    guard let dict = try PropertyListSerialization.propertyList(from: data, format: nil) as? [String: [String]] else {
        throw GeneratorError.invalidPlist("symbol_categories.plist is not [String: [String]]")
    }
    return dict
}

enum GeneratorError: Error, CustomStringConvertible {
    case invalidPlist(String)
    case missingArgument(String)

    var description: String {
        switch self {
        case .invalidPlist(let msg): return "Invalid plist: \(msg)"
        case .missingArgument(let msg): return "Missing argument: \(msg)"
        }
    }
}

// MARK: - Code generation

func generateCategoryFile(categories: [CategoryInfo]) -> String {
    var out = ""
    out += "// This file is auto-generated by SFSymbolsGenerator. Do not edit manually.\n"
    out += "// Source: SF Symbols.app/Contents/Resources/Metadata/categories.plist\n\n"
    out += "/// An official SF Symbols category as defined by Apple.\n"
    out += "public enum SFSymbolCategory: String, CaseIterable, Identifiable, Sendable {\n"

    for cat in categories {
        let escapedLabel = cat.label.replacingOccurrences(of: "\"", with: "\\\"")
        out += "    /// \(escapedLabel)\n"
        out += "    case \(cat.caseName) = \"\(cat.key)\"\n"
    }

    out += "\n"
    out += "    public var id: String { rawValue }\n\n"

    // label computed property
    out += "    /// Human-readable label, e.g. \"Communication\", \"Objects & Tools\".\n"
    out += "    public var label: String {\n"
    out += "        switch self {\n"
    for cat in categories {
        let escapedLabel = cat.label.replacingOccurrences(of: "\"", with: "\\\"")
        out += "        case .\(cat.caseName): return \"\(escapedLabel)\"\n"
    }
    out += "        }\n"
    out += "    }\n\n"

    // iconSymbolName computed property
    out += "    /// The SF Symbol name used as the category icon.\n"
    out += "    public var iconSymbolName: String {\n"
    out += "        switch self {\n"
    for cat in categories {
        out += "        case .\(cat.caseName): return \"\(cat.icon)\"\n"
    }
    out += "        }\n"
    out += "    }\n"
    out += "}\n"
    return out
}

func generateSymbolsFile(
    categories: [CategoryInfo],
    symbolCategories: [String: [String]]
) -> String {
    // Build a map from categoryKey -> sorted [symbolName]
    // Exclude the "all" pseudo-category — it's represented by CaseIterable
    let excludedKeys: Set<String> = ["all"]
    let validCategoryKeys = Set(categories.map(\.key)).subtracting(excludedKeys)

    // Use a Set per category to deduplicate — the plist can list the same symbol
    // under the same category more than once.
    var categoryToSymbolsSet: [String: Set<String>] = [:]
    for key in validCategoryKeys {
        categoryToSymbolsSet[key] = []
    }
    for (symbolName, cats) in symbolCategories {
        for cat in cats {
            guard validCategoryKeys.contains(cat) else { continue }
            categoryToSymbolsSet[cat, default: []].insert(symbolName)
        }
    }
    // Convert back to [String: [String]] for sorted iteration downstream
    let categoryToSymbols: [String: [String]] = categoryToSymbolsSet.mapValues { Array($0) }

    // Collect all unique symbols for the flat AnySymbol lookup table
    let allSymbols = symbolCategories.keys.sorted()

    var out = ""
    out += "// This file is auto-generated by SFSymbolsGenerator. Do not edit manually.\n"
    out += "// Source: SF Symbols.app/Contents/Resources/Metadata/symbol_categories.plist\n\n"
    out += "import Foundation\n\n"

    // MARK: Per-category enums
    // Emit in the same order as the categories plist
    let orderedCategories = categories.filter { !excludedKeys.contains($0.key) }

    for cat in orderedCategories {
        let symbols = (categoryToSymbols[cat.key] ?? []).sorted()
        guard !symbols.isEmpty else { continue }

        out += "// MARK: - \(cat.label)\n\n"
        out += "/// SF Symbols in the \"\(cat.label)\" category.\n"
        out += "public enum \(cat.caseName.prefix(1).uppercased() + cat.caseName.dropFirst())Symbol: String, SFSymbolProtocol, CaseIterable, Sendable {\n"

        // Track used case names to handle duplicates within a category
        var usedCaseNames: [String: Int] = [:]
        for symbol in symbols {
            var caseName = toCamelCase(symbol)
            if let count = usedCaseNames[caseName] {
                usedCaseNames[caseName] = count + 1
                caseName = "\(caseName)\(count + 1)"
            } else {
                usedCaseNames[caseName] = 1
            }
            out += "    case \(caseName) = \"\(symbol)\"\n"
        }

        out += "\n"
        out += "    public var symbolName: String { rawValue }\n"
        out += "    public var categories: [SFSymbolCategory] { [.\(cat.caseName)] }\n"
        out += "}\n\n"
    }

    // MARK: AnySymbol lookup table
    out += "// MARK: - All symbols lookup\n\n"
    out += "extension AnySymbol {\n"
    out += "    /// Every known SF Symbol as an ``AnySymbol``, sorted alphabetically.\n"
    out += "    public static let allSymbols: [AnySymbol] = [\n"
    for symbol in allSymbols {
        let cats = symbolCategories[symbol] ?? []
        let validCats = cats.filter { validCategoryKeys.contains($0) }
        let catsLiteral = validCats.map { key -> String in
            let caseName = categoryKeyToCamelCase[key] ?? key
            return ".\(caseName)"
        }.joined(separator: ", ")
        out += "        AnySymbol(rawValue: \"\(symbol)\", categories: [\(catsLiteral)]),\n"
    }
    out += "    ]\n"
    out += "}\n"

    return out
}

// MARK: - Entry point

func run() throws {
    let args = CommandLine.arguments
    // Usage: SFSymbolsGenerator <categoriesPlist> <symbolCategoriesPlist> <outputDir>
    guard args.count >= 4 else {
        throw GeneratorError.missingArgument(
            "Usage: SFSymbolsGenerator <categories.plist> <symbol_categories.plist> <outputDir>"
        )
    }

    let categoriesPlistURL = URL(fileURLWithPath: args[1])
    let symbolCategoriesPlistURL = URL(fileURLWithPath: args[2])
    let outputDir = URL(fileURLWithPath: args[3])

    let categories = try loadCategories(from: categoriesPlistURL)
    let symbolCategories = try loadSymbolCategories(from: symbolCategoriesPlistURL)

    try FileManager.default.createDirectory(at: outputDir, withIntermediateDirectories: true)

    let categorySource = generateCategoryFile(categories: categories)
    try categorySource.write(
        to: outputDir.appendingPathComponent("SFSymbolCategory.swift"),
        atomically: true,
        encoding: .utf8
    )

    let symbolsSource = generateSymbolsFile(categories: categories, symbolCategories: symbolCategories)
    try symbolsSource.write(
        to: outputDir.appendingPathComponent("GeneratedSymbols.swift"),
        atomically: true,
        encoding: .utf8
    )

    print("✓ Generated SFSymbolCategory.swift and GeneratedSymbols.swift in \(outputDir.path)")
}

do {
    try run()
} catch {
    fputs("error: \(error)\n", stderr)
    exit(1)
}
